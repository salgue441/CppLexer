/**
 * @file lexer.cpp
 * @author Carlos Salguero
 * @author Sergio Garnica
 * @brief Implementation of the Lexer class
 * @version 0.1
 * @date 2023-05-12
 *
 * @copyright Copyright (c) 2023
 *
 */

// Standard libraries
#include <iostream>
#include <fstream>

// Project files
#include "lexer.h"
#include "csharp_language.h"

// Access Methods
/**
 * @brief
 * Gets the tokens generated by the lexer
 * @return std::vector<Token> Vector of tokens
 */
std::vector<Token> Lexer::get_tokens() const
{
    return m_tokens;
}

// Methods (Public)
/**
 * @brief
 * Starts the lexing of the files
 * @param filenames Vector of filenames
 */
void Lexer::start_lexing(const std::vector<std::string> &filenames)
{
    lex(filenames);
}

// Methods (Private)
/**
 * @brief
 * Lex the files with parallel threads
 * @param filenames Vector of filenames
 */
void Lexer::lex(const std::vector<std::string> &filenames)
{
    try
    {
        for (const auto &filename : filenames)
            m_threads.emplace_back(&Lexer::lex_file, this,
                                   filename);

        for (auto &thread : m_threads)
            thread.join();
    }

    catch (std::exception &e)
    {
        std::cerr << e.what() << std::endl;
    }
}

/**
 * @brief
 * Lex a file and generate the tokens
 * @param filename Filename to lex
 * @throw std::runtime_error If the file cannot be opened
 */
void Lexer::lex_file(const std::string_view &filename)
{
    try
    {
        std::ifstream file(filename.data(), std::ios::in | std::ios::binary);

        if (!file)
            throw std::runtime_error("Cannot open file" +
                                     std::string(filename.data()));

        std::string buffer;
        std::string line;

        while (std::getline(file, line))
            buffer += line + '\n';

        file.close();

        std::lock_guard<std::mutex> lock(m_mutex);
        auto tokens = tokenize(buffer);

        m_tokens.insert(m_tokens.end(),
                        tokens.begin(), tokens.end());
    }
    catch (std::exception &e)
    {
        std::cerr << e.what() << std::endl;
    }
}

/**
 * @brief
 * Tokenizes the source code and generates the html code
 * @param buffer Source code to tokenize
 * @return std::vector<Token> Vector of html code
 * @throw std::runtime_error If the file cannot be opened
 */
std::vector<Token> Lexer::tokenize(const std::string_view &buffer)
{
    try
    {
        std::vector<Token> tokens;
        std::string_view delimiter{" \t\n\r\f\v"};
        std::size_t position{};
        std::size_t previous_position{};

        while ((position = buffer.find_last_of(delimiter, position)) != std::string::npos)
        {
            std::string_view token(buffer.data() + previous_position,
                                   position - previous_position);
            TokenType type = identify_token(token);
            m_tokens.emplace_back(token.data(), type);

            previous_position = position + 1;
            ++position;
        }

        return tokens;
    }
    catch (std::exception &e)
    {
        std::cerr << e.what() << std::endl;
    }

    throw std::runtime_error("Cannot tokenize file");
}

/**
 * @brief
 * Identify the token type based of the Token class
 * @param token Token to identify
 * @return TokenType Type of the token
 */
TokenType Lexer::identify_token(const std::string_view &token)
{
    if (std::binary_search(csharp::m_keywords.begin(),
                           csharp::m_keywords.end(), token))
        return TokenType::Keyword;

    else if (std::binary_search(csharp::m_operators.begin(),
                                csharp::m_operators.end(), token))
        return TokenType::Operator;

    else if (std::binary_search(csharp::m_separators.begin(),
                                csharp::m_separators.end(), token))
        return TokenType::Separator;

    else if (std::binary_search(csharp::m_comments.begin(),
                                csharp::m_comments.end(), token))
        return TokenType::Comment;

    else if (std::binary_search(csharp::m_literals.begin(),
                                csharp::m_literals.end(), token))
        return TokenType::Literal;

    else if (std::binary_search(csharp::m_preprocessor.begin(),
                                csharp::m_preprocessor.end(), token))
        return TokenType::Preprocessor;

    else if (std::binary_search(csharp::m_contextual_keywords.begin(),
                                csharp::m_contextual_keywords.end(),
                                token))
        return TokenType::ContextualKeyword;

    else if (std::binary_search(csharp::m_access_specifiers.begin(),
                                csharp::m_access_specifiers.end(),
                                token))
        return TokenType::AccessSpecifier;

    else if (std::binary_search(csharp::m_attribute_targets.begin(),
                                csharp::m_attribute_targets.end(),
                                token))
        return TokenType::AttributeTarget;

    else if (std::binary_search(csharp::m_attribute_usage.begin(),
                                csharp::m_attribute_usage.end(),
                                token))
        return TokenType::AttributeUsage;

    else if (std::binary_search(csharp::m_escaped_identifiers.begin(),
                                csharp::m_escaped_identifiers.end(),
                                token))
        return TokenType::EscapedIdentifier;

    else if (std::binary_search(csharp::m_interpolated_strings.begin(),
                                csharp::m_interpolated_strings.end(), token))
        return TokenType::InterpolatedStringLiteral;

    else if (std::binary_search(csharp::m_nullables.begin(),
                                csharp::m_nullables.end(), token))
        return TokenType::NullLiteral;

    else if (std::binary_search(csharp::m_verbatim_strings.begin(),
                                csharp::m_verbatim_strings.end(),
                                token))
        return TokenType::VerbatimStringLiteral;

    return TokenType::Other;
}

/**
 * @brief
 * Converts the tokens to html code. Uses the style.css defined classes
 * to color the tokens
 * @param tokens Tokens to convert
 * @return std::string Html code
 */
std::string Lexer::token_to_html(const Token &token)
{
    std::string html;

    switch (token.get_type())
    {
    case TokenType::Keyword:
        html += "<span class=\"Keyword\">" + token.get_value() + "</span>";
        break;

    case TokenType::Identifier:
        html += "<span class=\"Identifier\">" + token.get_value() + "</span>";
        break;

    case TokenType::Literal:
        html += "<span class=\"Literal\">" + token.get_value() + "</span>";
        break;

    case TokenType::Operator:
        html += "<span class=\"Operator\">" + token.get_value() + "</span>";
        break;

    case TokenType::Separator:
        html += "<span class=\"Separator\">" + token.get_value() + "</span>";
        break;

    case TokenType::Comment:
        html += "<span class=\"Comment\">" + token.get_value() + "</span>";
        break;

    case TokenType::Preprocessor:
        html += "<span class=\"Preprocessor\">" + token.get_value() + "</span>";
        break;

    case TokenType::ContextualKeyword:
        html += "<span class=\"ContextualKeyword\">" + token.get_value() + "</span>";
        break;

    case TokenType::AccessSpecifier:
        html += "<span class=\"AccessSpecifier\">" + token.get_value() + "</span>";
        break;

    case TokenType::AttributeTarget:
        html += "<span class=\"AttributeTarget\">" + token.get_value() + "</span>";
        break;

    case TokenType::AttributeUsage:
        html += "<span class=\"AttributeUsage\">" + token.get_value() + "</span>";
        break;

    case TokenType::EscapedIdentifier:
        html += "<span class=\"EscapedIdentifier\">" + token.get_value() + "</span>";
        break;

    case TokenType::InterpolatedStringLiteral:
        html += "<span class=\"InterpolatedStringLiteral\">" + token.get_value() + "</span>";
        break;

    case TokenType::NullLiteral:
        html += "<span class=\"NullLiteral\">" + token.get_value() + "</span>";
        break;

    case TokenType::VerbatimStringLiteral:
        html += "<span class=\"VerbatimStringLiteral\">" + token.get_value() + "</span>";
        break;

    case TokenType::RegularExpressionLiteral:
        html += "<span class=\"RegularExpressionLiteral\">" + token.get_value() + "</span>";
        break;

    case TokenType::NumericLiteral:
        html += "<span class=\"NumericLiteral\">" + token.get_value() + "</span>";
        break;

    case TokenType::Other:
        html += "<span class=\"Other\">" + token.get_value() + "</span>";
        break;
    }

    return html;
}